rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // Users collection - Strict ownership
    match /users/{userId} {
      allow read: if isAuthenticated() && isOwner(userId);
      allow write: if isAuthenticated() && isOwner(userId);

      // User Profile Subcollection
      match /profiles/{profileId} {
        allow read, write: if isAuthenticated() && isOwner(userId);
      }
      
      // Voice Lock Profile
      match /voiceLockProfile/{document=**} {
        allow read, write: if isAuthenticated() && isOwner(userId);
      }

      // Voice Datasets (User-scoped)
      match /voice_datasets/{datasetId} {
        allow read, write: if isAuthenticated() && isOwner(userId);
      }
      
      // Voice Samples (User-scoped)
      match /voiceSamples/{sampleId} {
        allow read, write: if isAuthenticated() && isOwner(userId);
      }
      
      // Legacy/Other subcollections
      match /viimProfile/{document=**} {
        allow read, write: if isAuthenticated() && isOwner(userId);
      }
    }

    // Conversations - Root collection method (queryable by userId)
    match /conversations/{conversationId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if isAuthenticated() && resource.data.userId == request.auth.uid;

      // Messages subcollection
      match /messages/{messageId} {
        allow read, write: if isAuthenticated() && get(/databases/$(database)/documents/conversations/$(conversationId)).data.userId == request.auth.uid;
      }
    }

    // Devices - Registry of user devices
    match /devices/{deviceId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Preferences - User settings
    match /preferences/{preferenceId} {
      // Allow read if owner (check field if exists) OR if ID matches pattern (for initial fetch of non-existent doc)
      allow read: if isAuthenticated() && (
        (resource != null && resource.data.userId == request.auth.uid) ||
        preferenceId == "pref_" + request.auth.uid
      );
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Subscriptions - per user document
    match /subscriptions/{userId} {
      allow read: if isAuthenticated() && isOwner(userId);
      allow create, update, delete: if isAuthenticated() && isOwner(userId);
    }

    // VoicePrints - Sensitive Biometric Data
    match /voiceprints/{voicePrintId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid; 
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid; 
    }

    // VIIM Sessions
    match /viimSessions/{sessionId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
    }

    // VIIM Datasets (Root level)
    match /viimDatasets/{datasetId} {
      allow read, write: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    // VIIM Verifications
    match /viimVerifications/{verificationId} {
       allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Beta waitlist (public, write-only)
    match /betaWaitlist/{docId} {
      allow create: if
        // simple email presence check to avoid empty spam writes
        request.resource.data.email is string &&
        request.resource.data.email.size() > 3 &&
        request.resource.data.email.size() <= 320;
      // No public reads or updates
      allow read, update, delete: if false;
    }

    // Voice Lock
    match /voiceLockProfiles/{userId} {
      allow read, write: if isAuthenticated() && isOwner(userId);
    }
    match /voiceLockDatasets/{datasetId} {
      allow read, write: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
    }
    match /voiceLockSamples/{sampleId} {
      allow read, write: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
    }
  }
}
